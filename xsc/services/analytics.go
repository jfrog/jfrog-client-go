package services

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/jfrog/jfrog-client-go/auth"
	"github.com/jfrog/jfrog-client-go/http/jfroghttpclient"
	"github.com/jfrog/jfrog-client-go/utils"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/io/httputils"
	servicesutils "github.com/jfrog/jfrog-client-go/xsc/services/utils"
	xscutils "github.com/jfrog/jfrog-client-go/xsc/services/utils"
)

const (
	AnalyticsMetricsMinXscVersion = "1.7.1"
	xscEventApi                   = "event"
	xscDeprecatedEventApiSuffix   = "api/v1/" + xscEventApi
)

type AnalyticsEventService struct {
	client          *jfroghttpclient.JfrogHttpClient
	XscDetails      auth.ServiceDetails
	XrayDetails     auth.ServiceDetails
	ScopeProjectKey string
}

func NewAnalyticsEventService(client *jfroghttpclient.JfrogHttpClient) *AnalyticsEventService {
	return &AnalyticsEventService{client: client}
}

func (vs *AnalyticsEventService) getAnalyticsEndPoint() string {
	if vs.XrayDetails != nil {
		return utils.AddTrailingSlashIfNeeded(vs.XrayDetails.GetUrl()) + xscutils.XscInXraySuffix + xscEventApi
	}
	// Backward compatibility
	return utils.AddTrailingSlashIfNeeded(vs.XscDetails.GetUrl()) + xscDeprecatedEventApiSuffix
}

func (vs *AnalyticsEventService) sendPostRequest(requestContent []byte) (resp *http.Response, body []byte, err error) {
	var httpClientDetails httputils.HttpClientDetails
	if vs.XrayDetails != nil {
		httpClientDetails = vs.XrayDetails.CreateHttpClientDetails()
	} else {
		// Backward compatibility
		httpClientDetails = vs.XscDetails.CreateHttpClientDetails()
	}
	resp, body, err = vs.client.SendPost(utils.AppendScopedProjectKeyParam(vs.getAnalyticsEndPoint(), vs.ScopeProjectKey), requestContent, &httpClientDetails)
	return
}

func (vs *AnalyticsEventService) sendPutRequest(requestContent []byte) (resp *http.Response, body []byte, err error) {
	var httpClientDetails httputils.HttpClientDetails
	if vs.XrayDetails != nil {
		httpClientDetails = vs.XrayDetails.CreateHttpClientDetails()
	} else {
		// Backward compatibility
		httpClientDetails = vs.XscDetails.CreateHttpClientDetails()
	}
	resp, body, err = vs.client.SendPut(utils.AppendScopedProjectKeyParam(vs.getAnalyticsEndPoint(), vs.ScopeProjectKey), requestContent, &httpClientDetails)
	return
}

func (vs *AnalyticsEventService) sendGetRequest(msi string) (resp *http.Response, body []byte, err error) {
	var httpClientDetails httputils.HttpClientDetails
	if vs.XrayDetails != nil {
		httpClientDetails = vs.XrayDetails.CreateHttpClientDetails()
	} else {
		// Backward compatibility
		httpClientDetails = vs.XscDetails.CreateHttpClientDetails()
	}
	resp, body, _, err = vs.client.SendGet(utils.AppendScopedProjectKeyParam(fmt.Sprintf("%s/%s", vs.getAnalyticsEndPoint(), msi), vs.ScopeProjectKey), true, &httpClientDetails)
	return

}

// AddGeneralEvent add general event in Xsc and returns msi generated by Xsc.
func (vs *AnalyticsEventService) AddGeneralEvent(event XscAnalyticsGeneralEvent, xrayVersion string) (string, error) {
	var requestContent []byte
	if err := utils.ValidateMinimumVersion(utils.Xray, xrayVersion, servicesutils.MinXrayVersionNewGitInfoContext); err != nil {
		// use deprecated event struct
		if requestContent, err = json.Marshal(convertToDeprecatedEventStruct(event)); err != nil {
			return "", errorutils.CheckError(err)
		}
	} else {
		if requestContent, err = json.Marshal(event); err != nil {
			return "", errorutils.CheckError(err)
		}
	}
	resp, body, err := vs.sendPostRequest(requestContent)
	if err != nil {
		return "", err
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusCreated); err != nil {
		return "", errorutils.CheckError(errorutils.GenerateResponseError(resp.Status, utils.IndentJson(body)))
	}
	var response XscAnalyticsGeneralEventResponse
	err = json.Unmarshal(body, &response)
	return response.MultiScanId, errorutils.CheckError(err)
}

// UpdateGeneralEvent update finalized analytics metrics info of an existing event.
func (vs *AnalyticsEventService) UpdateGeneralEvent(event XscAnalyticsGeneralEventFinalize) error {
	requestContent, err := json.Marshal(event)
	if err != nil {
		return errorutils.CheckError(err)
	}
	resp, body, err := vs.sendPutRequest(requestContent)
	if err != nil {
		return err
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusOK, http.StatusCreated); err != nil {
		return errorutils.CheckError(errorutils.GenerateResponseError(resp.Status, utils.IndentJson(body)))
	}
	return nil
}

// GetGeneralEvent returns event's data matching the provided multi scan id.
func (vs *AnalyticsEventService) GetGeneralEvent(msi string) (*XscAnalyticsGeneralEvent, error) {
	resp, body, err := vs.sendGetRequest(msi)
	if err != nil {
		return nil, err
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return nil, errorutils.CheckError(errorutils.GenerateResponseError(resp.Status, utils.IndentJson(body)))
	}
	var response XscAnalyticsGeneralEvent
	err = json.Unmarshal(body, &response)
	return &response, errorutils.CheckError(err)
}

func convertToDeprecatedEventStruct(event XscAnalyticsGeneralEvent) XscAnalyticsGeneralEventDeprecated {
	var deprecatedGitInfo XscGitInfoContextDeprecated
	if event.GitInfo != nil {
		deprecatedGitInfo = XscGitInfoContextDeprecated{
			GitRepoUrl:    event.GitInfo.Source.GitRepoHttpsCloneUrl,
			GitRepoName:   event.GitInfo.Source.GitRepoName,
			GitProject:    event.GitInfo.Source.GitProject,
			BranchName:    event.GitInfo.Source.BranchName,
			CommitHash:    event.GitInfo.Source.CommitHash,
			CommitMessage: event.GitInfo.Source.CommitMessage,
			CommitAuthor:  event.GitInfo.Source.CommitAuthor,
			GitProvider:   event.GitInfo.GitProvider,
			Technologies:  event.GitInfo.Technologies,
		}
	}
	return XscAnalyticsGeneralEventDeprecated{
		XscAnalyticsBasicGeneralEvent: event.XscAnalyticsBasicGeneralEvent,
		GitInfo:                       &deprecatedGitInfo,
		IsGitInfoFlow:                 event.IsGitInfoFlow,
	}
}

// XscAnalyticsGeneralEvent extend the basic struct with Frogbot related info.
type XscAnalyticsGeneralEventDeprecated struct {
	XscAnalyticsBasicGeneralEvent
	GitInfo       *XscGitInfoContextDeprecated `json:"gitinfo,omitempty"`
	IsGitInfoFlow bool                         `json:"is_gitinfo_flow,omitempty"`
}

type XscGitInfoContextDeprecated struct {
	GitRepoUrl    string   `json:"git_repo_url"`
	GitRepoName   string   `json:"git_repo_name,omitempty"`
	GitProject    string   `json:"git_project,omitempty"`
	GitProvider   string   `json:"git_provider,omitempty"`
	Technologies  []string `json:"technologies,omitempty"`
	BranchName    string   `json:"branch_name"`
	LastCommit    string   `json:"last_commit,omitempty"`
	CommitHash    string   `json:"commit_hash"`
	CommitMessage string   `json:"commit_message,omitempty"`
	CommitAuthor  string   `json:"commit_author,omitempty"`
}

type XscAnalyticsGeneralEvent struct {
	XscAnalyticsBasicGeneralEvent
	GitInfo       *XscGitInfoContext `json:"gitinfo,omitempty"`
	IsGitInfoFlow bool               `json:"is_gitinfo_flow,omitempty"`
}

type XscGitInfoContext struct {
	Source       CommitContext       `json:"source"`
	Target       *CommitContext      `json:"target,omitempty"`
	PullRequest  *PullRequestContext `json:"pull_request,omitempty"`
	GitProvider  string              `json:"git_provider,omitempty"`
	Technologies []string            `json:"technologies,omitempty"`
}

type CommitContext struct {
	GitRepoHttpsCloneUrl string `json:"git_repo_url"`
	GitRepoName          string `json:"git_repo_name,omitempty"`
	GitProject           string `json:"git_project,omitempty"`
	BranchName           string `json:"branch_name"`
	CommitHash           string `json:"commit_hash"`
	CommitMessage        string `json:"commit_message,omitempty"`
	CommitAuthor         string `json:"commit_author,omitempty"`
}

type PullRequestContext struct {
	PullRequestId    int    `json:"pull_request_id,omitempty"`
	PullRequestTitle string `json:"pull_request_title,omitempty"`
}

type XscAnalyticsGeneralEventFinalize struct {
	XscAnalyticsBasicGeneralEvent
	MultiScanId string `json:"multi_scan_id,omitempty"`
	GitRepoUrl  string `json:"git_repository,omitempty"`
}

type XscAnalyticsBasicGeneralEvent struct {
	EventType              EventType   `json:"event_type,omitempty"`
	EventStatus            EventStatus `json:"event_status,omitempty"`
	Product                ProductName `json:"product,omitempty"`
	ProductVersion         string      `json:"product_version,omitempty"`
	TotalFindings          int         `json:"total_findings,omitempty"`
	TotalIgnoredFindings   int         `json:"total_ignored_findings,omitempty"`
	IsDefaultConfig        bool        `json:"is_default_config,omitempty"`
	JfrogUser              string      `json:"jfrog_user,omitempty"`
	OsPlatform             string      `json:"os_platform,omitempty"`
	OsArchitecture         string      `json:"os_architecture,omitempty"`
	MachineId              string      `json:"machine_id,omitempty"`
	AnalyzerManagerVersion string      `json:"analyzer_manager_version,omitempty"`
	JpdVersion             string      `json:"jpd_version,omitempty"`
	TotalScanDuration      string      `json:"total_scan_duration,omitempty"`
	FrogbotScanType        string      `json:"frogbot_scan_type,omitempty"`
	FrogbotCiProvider      string      `json:"frogbot_ci_provider,omitempty"`
}

type XscAnalyticsGeneralEventResponse struct {
	MultiScanId string `json:"multi_scan_id,omitempty"`
}

type EventStatus string

const (
	Started   EventStatus = "started"
	Completed EventStatus = "completed"
	Cancelled EventStatus = "cancelled"
	Failed    EventStatus = "failed"
)

type ProductName string

const (
	CliProduct     ProductName = "cli"
	FrogbotProduct ProductName = "frogbot"
)

type EventType int

const (
	CliEventType EventType = 1
	FrogbotType  EventType = 8
)
